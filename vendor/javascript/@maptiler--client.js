import t from"quick-lru";function tryGettingFetch(){return typeof self!=="undefined"?fetch.bind(self):typeof global!=="undefined"&&global.fetch?global.fetch:null}class ClientConfig{constructor(){this._apiKey="";this._fetch=tryGettingFetch();this.tileCacheSize=200}set apiKey(t){this._apiKey=t}get apiKey(){return this._apiKey}set fetch(t){this._fetch=t}get fetch(){return this._fetch}}const e=new ClientConfig;const n={AUTO:"auto",ALBANIAN:"sq",ARABIC:"ar",ARMENIAN:"hy",AZERBAIJANI:"az",BELORUSSIAN:"be",BOSNIAN:"bs",BRETON:"br",BULGARIAN:"bg",CATALAN:"ca",CHINESE:"zh",CROATIAN:"hr",CZECH:"cs",DANISH:"da",DUTCH:"nl",ENGLISH:"en",ESPERANTO:"eo",ESTONIAN:"et",FINNISH:"fi",FRENCH:"fr",FRISIAN:"fy",GEORGIAN:"ka",GERMAN:"de",GREEK:"el",HEBREW:"he",HUNGARIAN:"hu",ICELANDIC:"is",IRISH:"ga",ITALIAN:"it",JAPANESE:"ja",KANNADA:"kn",KAZAKH:"kk",KOREAN:"ko",ROMAN_LATIN:"la",LATVIAN:"lv",LITHUANIAN:"lt",LUXEMBOURGISH:"lb",MACEDONIAN:"mk",MALTESE:"mt",NORWEGIAN:"no",POLISH:"pl",PORTUGUESE:"pt",ROMANIAN:"ro",ROMANSH:"rm",RUSSIAN:"ru",SCOTTISH_GAELIC:"gd",SERBIAN_CYRILLIC:"sr",SLOVAK:"sk",SLOVENE:"sl",SPANISH:"es",SWEDISH:"sv",THAI:"th",TURKISH:"tr",UKRAINIAN:"uk",WELSH:"cy"};const r=new Set(Object.values(n));function getAutoLanguageGeocoding(){if(typeof navigator==="undefined")return Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0];const t=Array.from(new Set(navigator.languages.map((t=>t.split("-")[0])))).filter((t=>r.has(t)));return t.length?t[0]:n.ENGLISH}async function callFetch(t,n={}){if(e.fetch===null)throw new Error("The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch");if(new URL(t).searchParams.get("key").trim()==="")throw new Error("The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com");return e.fetch(t,n)}const i={maptilerApiURL:"https://api.maptiler.com/",mapStyle:"streets-v2"};Object.freeze(i);class ServiceError extends Error{constructor(t,e=""){super(`Call to enpoint ${t.url} failed with the status code ${t.status}. ${e}`);this.res=t}}const a={400:"Query too long / Invalid parameters",403:"Key is missing, invalid or restricted"};function addLanguageGeocodingOptions(t,e){const{language:r}=e;if(r==void 0)return;const i=Array.from(new Set((Array.isArray(r)?r:[r]).map((t=>t===n.AUTO?getAutoLanguageGeocoding():t)))).join(",");t.set("language",i)}function addCommonForwardAndReverseGeocodingOptions(t,n){const{apiKey:r,limit:i,types:a,excludeTypes:o}=n;t.set("key",r??e.apiKey);i!=void 0&&t.set("limit",String(i));a!=void 0&&t.set("types",a.join(","));o!=void 0&&t.set("excludeTypes",String(o));addLanguageGeocodingOptions(t,n)}function addForwardGeocodingOptions(t,e){addCommonForwardAndReverseGeocodingOptions(t,e);const{bbox:n,proximity:r,country:i,fuzzyMatch:a,autocomplete:o}=e;n!=void 0&&t.set("bbox",n.join(","));r!=void 0&&t.set("proximity",r==="ip"?r:r.join(","));i!=void 0&&t.set("country",i.join(","));a!=void 0&&t.set("fuzzyMatch",a?"true":"false");o!=void 0&&t.set("autocomplete",o?"true":"false")}async function forward(t,e={}){if(typeof t!=="string"||t.trim().length===0)throw new Error("The query must be a non-empty string");const n=new URL(`geocoding/${encodeURIComponent(t)}.json`,i.maptilerApiURL);const{searchParams:r}=n;addForwardGeocodingOptions(r,e);const o=n.toString();const s=await callFetch(o);if(!s.ok)throw new ServiceError(s,a[s.status]??"");const c=await s.json();return c}async function reverse(t,e={}){if(!Array.isArray(t)||t.length<2)throw new Error("The position must be an array of form [lng, lat].");const n=new URL(`geocoding/${t[0]},${t[1]}.json`,i.maptilerApiURL);addCommonForwardAndReverseGeocodingOptions(n.searchParams,e);const r=n.toString();const o=await callFetch(r);if(!o.ok)throw new ServiceError(o,a[o.status]??"");const s=await o.json();return s}async function byId(t,n={}){const r=new URL(`geocoding/${t}.json`,i.maptilerApiURL);r.searchParams.set("key",n.apiKey??e.apiKey);addLanguageGeocodingOptions(r.searchParams,n);const o=r.toString();const s=await callFetch(o);if(!s.ok)throw new ServiceError(s,a[s.status]??"");const c=await s.json();return c}async function batch$1(t,e={}){if(!t.length)return[];const n=t.map((t=>encodeURIComponent(t))).join(";");const r=new URL(`geocoding/${n}.json`,i.maptilerApiURL);const{searchParams:o}=r;addForwardGeocodingOptions(o,e);const s=r.toString();const c=await callFetch(s);if(!c.ok)throw new ServiceError(c,a[c.status]??"");const l=await c.json();return t.length===1?[l]:l}const o={forward:forward,reverse:reverse,byId:byId,batch:batch$1,language:n};const s={403:"Key is missing, invalid or restricted"};async function info(t={}){const n=new URL("geolocation/ip.json",i.maptilerApiURL);n.searchParams.set("key",t.apiKey??e.apiKey);const r=n.toString();const a=await callFetch(r);if(!a.ok)throw new ServiceError(a,a.status in s?s[a.status]:"");const o=await a.json();return o}const c={info:info};const l={403:"Key is missing, invalid or restricted"};async function search(t,n={}){if(typeof t!=="string"||t.trim().length===0)throw new Error("The query must be a non-empty string");const r=new URL(`coordinates/search/${t}.json`,i.maptilerApiURL);r.searchParams.set("key",n.apiKey??e.apiKey);"limit"in n&&r.searchParams.set("limit",n.limit.toString());"transformations"in n&&r.searchParams.set("transformations",n.transformations.toString());"exports"in n&&r.searchParams.set("exports",n.exports.toString());const a=r.toString();const o=await callFetch(a);if(!o.ok)throw new ServiceError(o,o.status in l?l[o.status]:"");const s=await o.json();return s}async function transform(t,n={}){const r=(Array.isArray(t[0])?t:[t]).map((t=>`${t[0]},${t[1]}`)).join(";");const a=new URL(`coordinates/transform/${r}.json`,i.maptilerApiURL);a.searchParams.set("key",n.apiKey??e.apiKey);"sourceCrs"in n&&a.searchParams.set("s_srs",n.sourceCrs.toString());"targetCrs"in n&&a.searchParams.set("t_srs",n.targetCrs.toString());"operations"in n&&a.searchParams.set("ops",(Array.isArray(n.operations)?n.operations:[n.operations]).join("|"));const o=a.toString();const s=await callFetch(o);if(!s.ok)throw new ServiceError(s,s.status in l?l[s.status]:"");const c=await s.json();return c}const p={search:search,transform:transform};const h={403:"Key is missing, invalid or restricted"};async function get(t,n={}){if(typeof t!=="string"||t.trim().length===0)throw new Error("The data ID must be a non-empty string");const r=new URL(`data/${encodeURIComponent(t)}/features.json`,i.maptilerApiURL);r.searchParams.set("key",n.apiKey??e.apiKey);const a=r.toString();const o=await callFetch(a);if(!o.ok)throw new ServiceError(o,o.status in h?h[o.status]:"");const s=await o.json();return s}const m={get:get};function expandMapStyle(t){const e=/^maptiler:\/\/(.*)/;let n;const r=t.trim();let i;i=r.startsWith("http://")||r.startsWith("https://")?r:(n=e.exec(r))!==null?`https://api.maptiler.com/maps/${n[1]}/style.json`:`https://api.maptiler.com/maps/${r}/style.json`;return i}class MapStyleVariant{constructor(t,e,n,r,i,a){this.name=t;this.variantType=e;this.id=n;this.referenceStyle=r;this.description=i;this.imageURL=a}
/**
   * Get the human-friendly name
   * @returns
   */getName(){return this.name}getFullName(){return`${this.referenceStyle.getName()} ${this.name}`}
/**
   * Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
   * @returns
   */getType(){return this.variantType}
/**
   * Get the MapTiler Cloud id
   * @returns
   */getId(){return this.id}getDescription(){return this.description}
/**
   * Get the reference style this variant belongs to
   * @returns
   */getReferenceStyle(){return this.referenceStyle}
/**
   * Check if a variant of a given type exists for _this_ variants
   * (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
   * @param variantType
   * @returns
   */hasVariant(t){return this.referenceStyle.hasVariant(t)}
/**
   * Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
   * (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
   * @param variantType
   * @returns
   */getVariant(t){return this.referenceStyle.getVariant(t)}
/**
   * Get all the variants for _this_ variants, except _this_ current one
   * @returns
   */getVariants(){return this.referenceStyle.getVariants().filter((t=>t!==this))}
/**
   * Get the image URL that represent _this_ variant
   * @returns
   */getImageURL(){return this.imageURL}
/**
   * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
   * @returns
   */getExpandedStyleURL(){return expandMapStyle(this.getId())}}class ReferenceMapStyle{constructor(t,e){this.name=t;this.id=e;this.variants={};this.orderedVariants=[]}
/**
   * Get the human-friendly name of this reference style
   * @returns
   */getName(){return this.name}
/**
   * Get the id of _this_ reference style
   * @returns
   */getId(){return this.id}
/**
   * Add a variant to _this_ reference style
   * @param v
   */addVariant(t){this.variants[t.getType()]=t;this.orderedVariants.push(t)}
/**
   * Check if a given variant type exists for this reference style
   * @param variantType
   * @returns
   */hasVariant(t){return t in this.variants}
/**
   * Get a given variant. If the given type of variant does not exist for this reference style,
   * then the most relevant default variant is returned instead
   * @param variantType
   * @returns
   */getVariant(t){return t in this.variants?this.variants[t]:this.orderedVariants[0]}
/**
   * Get the list of variants for this reference style
   * @returns
   */getVariants(){return Object.values(this.variants)}
/**
   * Get the defualt variant for this reference style
   * @returns
   */getDefaultVariant(){return this.orderedVariants[0]}}const d=[{referenceStyleID:"STREETS",name:"Streets",description:"",variants:[{id:"streets-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"streets-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"streets-v2-light",name:"Light",variantType:"LIGHT",description:"",imageURL:""},{id:"streets-v2-night",name:"Night",variantType:"NIGHT",description:"",imageURL:""},{id:"streets-v2-pastel",name:"Pastel",variantType:"PASTEL",description:"",imageURL:""}]},{referenceStyleID:"OUTDOOR",name:"Outdoor",description:"",variants:[{id:"outdoor-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"outdoor-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""}]},{referenceStyleID:"WINTER",name:"Winter",description:"",variants:[{id:"winter-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"winter-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""}]},{referenceStyleID:"SATELLITE",name:"Satellite",description:"",variants:[{id:"satellite",name:"Default",variantType:"DEFAULT",description:"",imageURL:""}]},{referenceStyleID:"HYBRID",name:"Hybrid",description:"",variants:[{id:"hybrid",name:"Default",variantType:"DEFAULT",description:"",imageURL:""}]},{referenceStyleID:"BASIC",name:"Basic",description:"",variants:[{id:"basic-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"basic-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"basic-v2-light",name:"Light",variantType:"LIGHT",description:"",imageURL:""}]},{referenceStyleID:"BRIGHT",name:"Bright",description:"",variants:[{id:"bright-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"bright-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"bright-v2-light",name:"Light",variantType:"LIGHT",description:"",imageURL:""},{id:"bright-v2-pastel",name:"Pastel",variantType:"PASTEL",description:"",imageURL:""}]},{referenceStyleID:"OPENSTREETMAP",name:"OpenStreetMap",description:"",variants:[{id:"openstreetmap",name:"Default",variantType:"DEFAULT",description:"",imageURL:""}]},{referenceStyleID:"TOPO",name:"Topo",description:"",variants:[{id:"topo-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"topo-v2-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"topo-v2-shiny",name:"Shiny",variantType:"SHINY",description:"",imageURL:""},{id:"topo-v2-pastel",name:"Pastel",variantType:"PASTEL",description:"",imageURL:""},{id:"topo-v2-topographique",name:"Topographique",variantType:"TOPOGRAPHIQUE",description:"",imageURL:""}]},{referenceStyleID:"VOYAGER",name:"Voyager",description:"",variants:[{id:"voyager-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"voyager-v2-darkmatter",name:"Darkmatter",variantType:"DARK",description:"",imageURL:""},{id:"voyager-v2-positron",name:"Positron",variantType:"LIGHT",description:"",imageURL:""},{id:"voyager-v2-vintage",name:"Vintage",variantType:"VINTAGE",description:"",imageURL:""}]},{referenceStyleID:"TONER",name:"Toner",description:"",variants:[{id:"toner-v2",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"toner-v2-background",name:"Background",variantType:"BACKGROUND",description:"",imageURL:""},{id:"toner-v2-lite",name:"Lite",variantType:"LITE",description:"",imageURL:""},{id:"toner-v2-lines",name:"Lines",variantType:"LINES",description:"",imageURL:""}]},{referenceStyleID:"DATAVIZ",name:"Dataviz",description:"",variants:[{id:"dataviz",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"dataviz-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"dataviz-light",name:"Light",variantType:"LIGHT",description:"",imageURL:""}]},{referenceStyleID:"BACKDROP",name:"Backdrop",description:"",variants:[{id:"backdrop",name:"Default",variantType:"DEFAULT",description:"",imageURL:""},{id:"backdrop-dark",name:"Dark",variantType:"DARK",description:"",imageURL:""},{id:"backdrop-light",name:"Light",variantType:"LIGHT",description:"",imageURL:""}]},{referenceStyleID:"OCEAN",name:"Ocean",description:"",variants:[{id:"ocean",name:"Default",variantType:"DEFAULT",description:"",imageURL:""}]}];function makeReferenceStyleProxy(t){return new Proxy(t,{get(e,n,r){return e.hasVariant(n)?e.getVariant(n):n.toString().toUpperCase()===n?t.getDefaultVariant():Reflect.get(e,n,r)}})}function buildMapStyles(){const t={};for(let e=0;e<d.length;e+=1){const n=d[e];const r=makeReferenceStyleProxy(new ReferenceMapStyle(n.name,n.referenceStyleID));for(let t=0;t<n.variants.length;t+=1){const e=n.variants[t];const i=new MapStyleVariant(e.name,e.variantType,e.id,r,e.description,e.imageURL);r.addVariant(i)}t[n.referenceStyleID]=r}return t}function styleToStyle(t){return t?typeof t==="string"||t instanceof String?t.trim().toLowerCase():t instanceof MapStyleVariant?t.getId():t instanceof ReferenceMapStyle?t.getDefaultVariant().getId():void 0:g[d[0].referenceStyleID].getDefaultVariant().getId()}const g=buildMapStyles();function extractLineStrings(t){const e=[];function extractFromGeometry(t){t.type!=="LineString"&&t.type!=="MultiLineString"||e.push(t)}function extractFromFeature(t){t.geometry&&extractFromGeometry(t.geometry)}function extractFromFeatureCollection(t){for(const e of t.features)e.type==="Feature"?extractFromFeature(e):e.type==="FeatureCollection"&&extractFromFeatureCollection(e)}t.type==="Feature"?extractFromFeature(t):t.type==="FeatureCollection"?extractFromFeatureCollection(t):extractFromGeometry(t);return e}function getSqSegDist(t,e,n){let r=e[0],i=e[1],a=n[0]-r,o=n[1]-i;if(a!==0||o!==0){const e=((t[0]-r)*a+(t[1]-i)*o)/(a*a+o*o);if(e>1){r=n[0];i=n[1]}else if(e>0){r+=a*e;i+=o*e}}a=t[0]-r;o=t[1]-i;return a*a+o*o}function simplifyDPStep(t,e,n,r,i){let a,o=r;for(let r=e+1;r<n;r++){const i=getSqSegDist(t[r],t[e],t[n]);if(i>o){a=r;o=i}}if(o>r){a-e>1&&simplifyDPStep(t,e,a,r,i);i.push(t[a]);n-a>1&&simplifyDPStep(t,a,n,r,i)}}function simplifyDouglasPeucker(t,e){const n=t.length-1;const r=[t[0]];simplifyDPStep(t,0,n,e,r);r.push(t[n]);return r}function simplify(t,e){if(t.length<=2)return t;const n=e!==void 0?e*e:1;const r=simplifyDouglasPeucker(t,n);return r}const u={extractLineStrings:extractLineStrings,simplify:simplify};function staticMapMarkerToString(t,e=true){let n=`${t[0]},${t[1]}`;t.length===3&&e&&(n+=`,${t[2]}`);return n}function simplifyAndStringify(t,e=3e3){let n=t.map((t=>t.join(","))).join("|");let r=5e-6;const i=1e-5;while(n.length>e){const e=u.simplify(t,r);n=e.map((t=>`${t[0]},${t[1]}`)).join("|");r+=i}return n}function centered(t,n,r={}){const a=styleToStyle(r.style);const o=r.hiDPI?"@2x":"";const s=r.format??"png";let c=~~(r.width??1024);let l=~~(r.height??1024);if(r.hiDPI){c=~~(c/2);l=~~(l/2)}const p=new URL(`maps/${encodeURIComponent(a)}/static/${t[0]},${t[1]},${n}/${c}x${l}${o}.${s}`,i.maptilerApiURL);"attribution"in r&&p.searchParams.set("attribution",r.attribution.toString());if("markers"in r){let t="";const e="markerIcon"in r;e&&(t+=`icon:${r.markerIcon}|`);e&&"markerAnchor"in r&&(t+=`anchor:${r.markerAnchor}|`);e&&r.hiDPI&&(t+="scale:2|");const n=Array.isArray(r.markers[0])?r.markers:[r.markers];t+=n.map((t=>staticMapMarkerToString(t,!e))).join("|");p.searchParams.set("markers",t)}if("path"in r){let t="";t+=`fill:${r.pathFillColor??"none"}|`;"pathStrokeColor"in r&&(t+=`stroke:${r.pathStrokeColor}|`);if("pathWidth"in r){const e=r.pathWidth/(r.hiDPI?2:1);t+=`width:${e.toString()}|`}t+=simplifyAndStringify(r.path);p.searchParams.set("path",t)}p.searchParams.set("key",r.apiKey??e.apiKey);return p.toString()}function bounded(t,n={}){const r=styleToStyle(n.style);const a=n.hiDPI?"@2x":"";const o=n.format??"png";let s=~~(n.width??1024);let c=~~(n.height??1024);if(n.hiDPI){s=~~(s/2);c=~~(c/2)}const l=new URL(`maps/${encodeURIComponent(r)}/static/${t[0]},${t[1]},${t[2]},${t[3]}/${s}x${c}${a}.${o}`,i.maptilerApiURL);"attribution"in n&&l.searchParams.set("attribution",n.attribution.toString());"padding"in n&&l.searchParams.set("padding",n.padding.toString());if("markers"in n){let t="";const e="markerIcon"in n;e&&(t+=`icon:${n.markerIcon}|`);e&&"markerAnchor"in n&&(t+=`anchor:${n.markerAnchor}|`);e&&n.hiDPI&&(t+="scale:2|");const r=Array.isArray(n.markers[0])?n.markers:[n.markers];t+=r.map((t=>staticMapMarkerToString(t,!e))).join("|");l.searchParams.set("markers",t)}if("path"in n){let t="";t+=`fill:${n.pathFillColor??"none"}|`;"pathStrokeColor"in n&&(t+=`stroke:${n.pathStrokeColor}|`);if("pathWidth"in n){const e=n.pathWidth/(n.hiDPI?2:1);t+=`width:${e.toString()}|`}t+=simplifyAndStringify(n.path);l.searchParams.set("path",t)}l.searchParams.set("key",n.apiKey??e.apiKey);return l.toString()}function automatic(t={}){if(!("markers"in t)&&!("path"in t))throw new Error("Automatic static maps require markers and/or path to be created.");const n=styleToStyle(t.style);const r=t.hiDPI?"@2x":"";const a=t.format??"png";let o=~~(t.width??1024);let s=~~(t.height??1024);if(t.hiDPI){o=~~(o/2);s=~~(s/2)}const c=new URL(`maps/${encodeURIComponent(n)}/static/auto/${o}x${s}${r}.${a}`,i.maptilerApiURL);"attribution"in t&&c.searchParams.set("attribution",t.attribution.toString());"padding"in t&&c.searchParams.set("padding",t.padding.toString());if("markers"in t){let e="";const n="markerIcon"in t;n&&(e+=`icon:${t.markerIcon}|`);n&&"markerAnchor"in t&&(e+=`anchor:${t.markerAnchor}|`);n&&t.hiDPI&&(e+="scale:2|");const r=Array.isArray(t.markers[0])?t.markers:[t.markers];e+=r.map((t=>staticMapMarkerToString(t,!n))).join("|");c.searchParams.set("markers",e)}if("path"in t){let e="";e+=`fill:${t.pathFillColor??"none"}|`;"pathStrokeColor"in t&&(e+=`stroke:${t.pathStrokeColor}|`);if("pathWidth"in t){const n=t.pathWidth/(t.hiDPI?2:1);e+=`width:${n.toString()}|`}e+=simplifyAndStringify(t.path);c.searchParams.set("path",e)}c.searchParams.set("key",t.apiKey??e.apiKey);return c.toString()}const f={centered:centered,bounded:bounded,automatic:automatic};const y=6371008.8;const S=2*Math.PI*y;function longitudeToMercatorX(t){return(180+t)/360}function latitudeToMercatorY(t){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360)))/360}function wgs84ToMercator(t){const e=wrapWgs84(t);return[longitudeToMercatorX(e[0]),latitudeToMercatorY(e[1])]}function mercatorXToLongitude(t){return t*360-180}function mercatorYToLatitude(t){const e=180-t*360;return 360/Math.PI*Math.atan(Math.exp(e*Math.PI/180))-90}function mercatorToWgs84(t){return[mercatorXToLongitude(t[0]),mercatorYToLatitude(t[1])]}function haversineDistanceWgs84(t,e){const n=Math.PI/180;const r=t[1]*n;const i=e[1]*n;const a=Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos((e[0]-t[0])*n);const o=y*Math.acos(Math.min(a,1));return o}function haversineCumulatedDistanceWgs84(t){const e=Array(t.length);e[0]=0;const n=e.length;for(let r=1;r<n;r++)e[r]=haversineDistanceWgs84(t[r-1],t[r])+e[r-1];return e}function wrapWgs84(t){const e=t[0];const n=t[1];const r=360;const i=((e+180)%r+r)%r-180;const a=i===-180?180:i;return[a,n]}function circumferenceAtLatitude(t){return S*Math.cos(t*Math.PI/180)}function mercatorToTileIndex(t,e,n=true){const r=2**e;const i=[t[0]*r,t[1]*r];return n?[~~i[0],~~i[1]]:i}function wgs84ToTileIndex(t,e,n=true){const r=wgs84ToMercator(t);return mercatorToTileIndex(r,e,n)}function toRadians(t){return t*Math.PI/180}function toDegrees(t){return t*180/Math.PI}function haversineIntermediateWgs84(t,e,n){const r=haversineDistanceWgs84(t,e);const i=toRadians(t[0]);const a=toRadians(t[1]);const o=toRadians(e[0]);const s=toRadians(e[1]);const c=r/y;const l=Math.sin((1-n)*c)/Math.sin(c);const p=Math.sin(n*c)/Math.sin(c);const h=l*Math.cos(a)*Math.cos(i)+p*Math.cos(s)*Math.cos(o);const m=l*Math.cos(a)*Math.sin(i)+p*Math.cos(s)*Math.sin(o);const d=l*Math.sin(a)+p*Math.sin(s);const g=Math.atan2(d,Math.sqrt(h*h+m*m));const u=Math.atan2(m,h);return[toDegrees(u),toDegrees(g)]}const T={EARTH_RADIUS:y,EARTH_CIRCUMFERENCE:S,longitudeToMercatorX:longitudeToMercatorX,latitudeToMercatorY:latitudeToMercatorY,wgs84ToMercator:wgs84ToMercator,mercatorXToLongitude:mercatorXToLongitude,mercatorYToLatitude:mercatorYToLatitude,mercatorToWgs84:mercatorToWgs84,haversineDistanceWgs84:haversineDistanceWgs84,wrapWgs84:wrapWgs84,circumferenceAtLatitude:circumferenceAtLatitude,mercatorToTileIndex:mercatorToTileIndex,wgs84ToTileIndex:wgs84ToTileIndex,toRadians:toRadians,toDegrees:toDegrees,haversineIntermediateWgs84:haversineIntermediateWgs84,haversineCumulatedDistanceWgs84:haversineCumulatedDistanceWgs84};let v=null;function getTileCache(){v||(v=new t({maxSize:e.tileCacheSize}));return v}async function bufferToPixelDataBrowser(t){const e=new Blob([t]);const n=await createImageBitmap(e);const r=document.createElement("canvas");const i=r.getContext("2d");r.width=n.width;r.height=n.height;i.drawImage(n,0,0);const a=i.getImageData(0,0,r.width,r.height);return{pixels:a.data,width:r.width,height:r.height,components:a.data.length/(r.width*r.height)}}function getBufferToPixelDataParser(){if(e.bufferToPixelData)return e.bufferToPixelData;if(typeof window!=="undefined")return bufferToPixelDataBrowser;throw new Error("An image file buffer to pixel data parser is necessary. Specify it in `config.bufferToPixelData`")}const L="tiles/terrain-rgb-v2/tiles.json";let A=null;const w={403:"Key is missing, invalid or restricted"};async function fetchTerrainTileJson(t){const e=new URL(L,i.maptilerApiURL);e.searchParams.set("key",t);const n=e.toString();const r=await callFetch(n);if(r.ok){A=await r.json();return A}if(!r.ok)throw new ServiceError(r,w[r.status]??"")}async function at(t,n={}){const r=n.apiKey??e.apiKey;A||await fetchTerrainTileJson(r);const i=A.maxzoom;let a=~~(n.zoom??i);(a>i||a<0)&&(a=i);const o=T.wgs84ToTileIndex(t,a,false);const s=~~o[0];const c=~~o[1];if(!A.tiles.length)throw new Error("Terrain tileJSON tile list is empty.");const l=`terrain_${a.toString()}_${s.toString()}_${c.toString()}`;let p;const h=getTileCache();if(h.has(l))p=h.get(l);else{const t=A.tiles[0].replace("{x}",s.toString()).replace("{y}",c.toString()).replace("{z}",a.toString());const e=await callFetch(t);if(!e.ok)throw new ServiceError(e,w[e.status]??"");const n=await e.arrayBuffer();const r=getBufferToPixelDataParser();p=await r(n);h.set(l,p)}const m=~~(p.width*(o[0]%1));const d=~~(p.height*(o[1]%1));const g=(d*p.width+m)*p.components;const u=p.pixels[g];const f=p.pixels[g+1];const y=p.pixels[g+2];const S=(u*256*256+f*256+y)*.1-1e4;return[t[0],t[1],S]}async function batch(t,n={}){const r=n.apiKey??e.apiKey;A||await fetchTerrainTileJson(r);const i=getBufferToPixelDataParser();const a=A.tiles[0];const o=getTileCache();const s=A.maxzoom;let c=~~(n.zoom??s);(c>s||c<0)&&(c=s);const l=t.map((t=>T.wgs84ToTileIndex(t,c,false)));const p=l.map((t=>[~~t[0],~~t[1]]));const h=p.map((t=>`terrain_${c.toString()}_${t[0].toString()}_${t[1].toString()}`));const m=Array.from(new Set(h.filter((t=>!o.has(t))))).map((t=>t.split("_").slice(1)));const d=m.map((t=>a.replace("{x}",t[1].toString()).replace("{y}",t[2].toString()).replace("{z}",t[0].toString())));const g=d.map((t=>callFetch(t)));const u=await Promise.allSettled(g);const f=u.map((t=>t.status==="fulfilled"?t.value:null)).filter((t=>t));const y=f.filter((t=>!t.ok));if(f.length!==g.length)throw new Error("Some tiles could not be fetched.");if(y.length)throw new ServiceError(y[0],w[y[0].status]??"");const S=await Promise.all(f.map((t=>t.arrayBuffer())));if(!S.every((t=>t.byteLength>0)))throw new Error("Some tiles are not available.");const v=await Promise.all(S.map((t=>i(t))));v.forEach(((t,e)=>{const n=m[e];const r=`terrain_${n[0].toString()}_${n[1].toString()}_${n[2].toString()}`;o.set(r,t)}));const L=t.map(((t,e)=>{const n=h[e];const r=l[e];const i=o.get(n);const a=Math.min(Math.round(i.width*(r[0]%1)),i.width-1);const s=Math.min(Math.round(i.height*(r[1]%1)),i.height-1);const c=(s*i.width+a)*i.components;const p=i.pixels[c];const m=i.pixels[c+1];const d=i.pixels[c+2];const g=(p*256*256+m*256+d)*.1-1e4;return[t[0],t[1],~~(g*1e3)/1e3]}));if(n.smoothingKernelSize){const t=2*~~(n.smoothingKernelSize/2)+1;const e=L.map((t=>t[2]));const r=~~(t/2);for(let n=r;n<e.length-r-1;n+=1){let i=0;for(let a=0;a<t;a+=1){const t=e[n-r+a];i+=t}i/=t;L[n][2]=i}}return L}async function fromLineString(t,e={}){if(t.type!=="LineString")throw new Error("The provided object is not a GeoJSON LineString");const n=structuredClone(t);const r=await batch(n.coordinates,e);n.coordinates=r;return n}async function fromMultiLineString(t,e={}){if(t.type!=="MultiLineString")throw new Error("The provided object is not a GeoJSON MultiLineString");const n=structuredClone(t);const r=n.coordinates.map((t=>t.length));const i=n.coordinates.flat();const a=await batch(i,e);const o=[];let s=0;for(const t of r){o.push(a.slice(s,s+t));s+=t}n.coordinates=o;return n}const I={at:at,batch:batch,fromLineString:fromLineString,fromMultiLineString:fromMultiLineString};export{ClientConfig,n as LanguageGeocoding,g as MapStyle,MapStyleVariant,ReferenceMapStyle,ServiceError,bufferToPixelDataBrowser,circumferenceAtLatitude,e as config,p as coordinates,m as data,I as elevation,expandMapStyle,o as geocoding,c as geolocation,getAutoLanguageGeocoding,getBufferToPixelDataParser,getTileCache,d as mapStylePresetList,T as math,u as misc,f as staticMaps,styleToStyle};

