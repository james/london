class QuickLRU extends Map{#e=0;#t=new Map;#i=new Map;#s;#h;#c;constructor(e={}){super();if(!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if("number"===typeof e.maxAge&&0===e.maxAge)throw new TypeError("`maxAge` must be a number greater than 0");this.#s=e.maxSize;this.#h=e.maxAge||Number.POSITIVE_INFINITY;this.#c=e.onEviction}get __oldCache(){return this.#i}#a(e){if("function"===typeof this.#c)for(const[t,i]of e)this.#c(t,i.value)}#n(e,t){if("number"===typeof t.expiry&&t.expiry<=Date.now()){"function"===typeof this.#c&&this.#c(e,t.value);return this.delete(e)}return false}#o(e,t){const i=this.#n(e,t);if(false===i)return t.value}#r(e,t){return t.expiry?this.#o(e,t):t.value}#l(e,t){const i=t.get(e);return this.#r(e,i)}#d(e,t){this.#t.set(e,t);this.#e++;if(this.#e>=this.#s){this.#e=0;this.#a(this.#i);this.#i=this.#t;this.#t=new Map}}#f(e,t){this.#i.delete(e);this.#d(e,t)}*#u(){for(const e of this.#i){const[t,i]=e;if(!this.#t.has(t)){const s=this.#n(t,i);false===s&&(yield e)}}for(const e of this.#t){const[t,i]=e;const s=this.#n(t,i);false===s&&(yield e)}}get(e){if(this.#t.has(e)){const t=this.#t.get(e);return this.#r(e,t)}if(this.#i.has(e)){const t=this.#i.get(e);if(false===this.#n(e,t)){this.#f(e,t);return t.value}}}set(e,t,{maxAge:i=this.#h}={}){const s="number"===typeof i&&i!==Number.POSITIVE_INFINITY?Date.now()+i:void 0;this.#t.has(e)?this.#t.set(e,{value:t,expiry:s}):this.#d(e,{value:t,expiry:s});return this}has(e){return this.#t.has(e)?!this.#n(e,this.#t.get(e)):!!this.#i.has(e)&&!this.#n(e,this.#i.get(e))}peek(e){return this.#t.has(e)?this.#l(e,this.#t):this.#i.has(e)?this.#l(e,this.#i):void 0}delete(e){const t=this.#t.delete(e);t&&this.#e--;return this.#i.delete(e)||t}clear(){this.#t.clear();this.#i.clear();this.#e=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const t=[...this.#u()];const i=t.length-e;if(i<0){this.#t=new Map(t);this.#i=new Map;this.#e=t.length}else{i>0&&this.#a(t.slice(0,i));this.#i=new Map(t.slice(i));this.#t=new Map;this.#e=0}this.#s=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.#t){const[t,i]=e;const s=this.#n(t,i);false===s&&(yield[t,i.value])}for(const e of this.#i){const[t,i]=e;if(!this.#t.has(t)){const e=this.#n(t,i);false===e&&(yield[t,i.value])}}}*entriesDescending(){let e=[...this.#t];for(let t=e.length-1;t>=0;--t){const i=e[t];const[s,h]=i;const c=this.#n(s,h);false===c&&(yield[s,h.value])}e=[...this.#i];for(let t=e.length-1;t>=0;--t){const i=e[t];const[s,h]=i;if(!this.#t.has(s)){const e=this.#n(s,h);false===e&&(yield[s,h.value])}}}*entriesAscending(){for(const[e,t]of this.#u())yield[e,t.value]}get size(){if(!this.#e)return this.#i.size;let e=0;for(const t of this.#i.keys())this.#t.has(t)||e++;return Math.min(this.#e+e,this.#s)}get maxSize(){return this.#s}entries(){return this.entriesAscending()}forEach(e,t=this){for(const[i,s]of this.entriesAscending())e.call(t,s,i,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}export{QuickLRU as default};

